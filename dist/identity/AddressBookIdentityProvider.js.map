{"version":3,"sources":["../../src/identity/AddressBookIdentityProvider.js"],"names":["addressBookAppIds","AddressBookIdentityProvider","AddressIdentityProvider","constructor","apps","cache","resolve","address","toLowerCase","pipe","app","includes","appId","cacheKey","proxyAddress","entries","get","data","metadata","find","entry","addr","source","pendingEntryData","toPromise","search","searchTerm","isAddressSearch","substring","identities","getAll","results","Object","filter","name","length","indexOf","map","allEntries","allEntriesResolved","entriesObject","reduce","obj","Promise","modify","Error"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA,MAAMA,iBAAiB,GAAG,CACxB,oBAAS,cAAT,CADwB,EAExB,oBAAS,mBAAT,CAFwB,EAGxB,oBAAS,gCAAT,CAHwB,EAIxB,oBAAS,uBAAT,CAJwB,EAKxB,oBAAS,2BAAT,CALwB,EAMxB,oBAAS,oBAAT,CANwB,CAA1B;AAQA;;;;;;AAKe,MAAMC,2BAAN,SAA0CC,gCAA1C,CAAkE;AAC/E;;;;;AAKAC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,KAAR,EAAe;AACxB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;AAED;;;;;;;;;;AAQA,QAAMC,OAAN,CAAeC,OAAf,EAAwB;AACtBA,IAAAA,OAAO,GAAGA,OAAO,CAACC,WAAR,EAAV;AACA,WAAO,KAAKJ,IAAL,CAAUK,IAAV,CACL,2BADK,EAEL,uBAAOC,GAAG,IAAIV,iBAAiB,CAACW,QAAlB,CAA2BD,GAAG,CAACE,KAA/B,CAAd,CAFK,EAGL,oBAAI,MAAMF,GAAN,IAAa;AACf,YAAMG,QAAQ,GAAG,wBAAYH,GAAG,CAACI,YAAhB,EAA8B,OAA9B,CAAjB;AACA,YAAM;AAAEC,QAAAA,OAAO,GAAG;AAAZ,UAAmB,MAAM,KAAKV,KAAL,CAAWW,GAAX,CAAeH,QAAf,CAA/B;AACA,YAAM;AAAEI,QAAAA,IAAI,EAAEC;AAAR,UAAqBH,OAAO,CAC/BI,IADwB,CACnBC,KAAK,IAAIA,KAAK,CAACC,IAAN,CAAWb,WAAX,OAA6BD,OADnB,KAC+B,EAD1D;AAEA,UAAI,CAACW,QAAL,EAAe,OAAO,IAAP;AACfA,MAAAA,QAAQ,CAACI,MAAT,GAAkB,aAAlB;AACA,aAAOJ,QAAP;AACD,KARD,CAHK,EAYL,wBAAQK,gBAAgB,IAAI,gBAAKA,gBAAL,CAA5B,CAZK,EAaL,+BAAe,IAAf,CAbK,EAcL,uBAdK,EAeLC,SAfK,EAAP;AAgBD;AAED;;;;;;;;;;AAQA,QAAMC,MAAN,CAAcC,UAAU,GAAG,EAA3B,EAA+B;AAC7B,UAAMC,eAAe,GAAGD,UAAU,CAACE,SAAX,CAAqB,CAArB,EAAwB,CAAxB,EAA2BpB,WAA3B,OAA6C,IAArE;AACA,UAAMqB,UAAU,GAAG,MAAM,KAAKC,MAAL,EAAzB;AACA,UAAMC,OAAO,GAAGC,MAAM,CAACjB,OAAP,CAAec,UAAf,EACbI,MADa,CAEZ,CAAC,CAAC1B,OAAD,EAAU;AAAE2B,MAAAA;AAAF,KAAV,CAAD,KACGP,eAAe,IACdD,UAAU,CAACS,MAAX,GAAoB,CADrB,IAEC5B,OAAO,CAACC,WAAR,GAAsB4B,OAAtB,CAA8BV,UAAU,CAAClB,WAAX,EAA9B,MAA4D,CAF9D,IAGA0B,IAAI,CAAC1B,WAAL,GAAmB4B,OAAnB,CAA2BV,UAAU,CAAClB,WAAX,EAA3B,IAAuD,CAAC,CAN9C,EAQb6B,GARa,CAQT,CAAC,CAAC9B,OAAD,EAAU;AAAE2B,MAAAA;AAAF,KAAV,CAAD,MAA0B;AAAEA,MAAAA,IAAF;AAAQ3B,MAAAA;AAAR,KAA1B,CARS,CAAhB;AASA,WAAOwB,OAAP;AACD;AAED;;;;;;;AAKA,QAAMD,MAAN,GAAgB;AACd,WAAO,KAAK1B,IAAL,CAAUK,IAAV,CACL,uBADK,EAEL,2BAFK,EAGL,uBAAOC,GAAG,IAAIV,iBAAiB,CAACW,QAAlB,CAA2BD,GAAG,CAACE,KAA/B,CAAd,CAHK,EAIL,uBACE,OAAO0B,UAAP,EAAmB5B,GAAnB,KAA2B;AACzB,YAAMG,QAAQ,GAAG,wBAAYH,GAAG,CAACI,YAAhB,EAA8B,OAA9B,CAAjB;AACA,YAAM;AAAEC,QAAAA,OAAO,GAAG;AAAZ,UAAmB,MAAM,KAAKV,KAAL,CAAWW,GAAX,CAAeH,QAAf,CAA/B;AACA,YAAM0B,kBAAkB,GAAG,MAAMD,UAAjC;AACA,YAAME,aAAa,GAAGzB,OAAO,CAAC0B,MAAR,CAAe,CAACC,GAAD,EAAMtB,KAAN,KAAgB;AACnD,iCAAYsB,GAAZ;AAAiB,WAACtB,KAAK,CAACC,IAAN,CAAWb,WAAX,EAAD,GAA4BY,KAAK,CAACH;AAAnD;AACD,OAFqB,EAEnB,EAFmB,CAAtB,CAJyB,CAOzB;;AACA,+BAAYuB,aAAZ,MAA8BD,kBAA9B;AACD,KAVH,EAWEI,OAAO,CAACrC,OAAR,CAAgB,EAAhB,CAXF,CAJK,EAiBLkB,SAjBK,EAAP;AAkBD;AAED;;;;;;;;;AAOA,QAAMoB,MAAN,CAAcrC,OAAd,EAAuBW,QAAvB,EAAiC;AAC/B,UAAM,IAAI2B,KAAJ,CAAU,2EAAV,CAAN;AACD;;AAlG8E","sourcesContent":["import AddressIdentityProvider from './AddressIdentityProvider'\nimport { from } from 'rxjs'\nimport { concatAll, first, map, filter, flatMap, defaultIfEmpty, reduce } from 'rxjs/operators'\nimport { getCacheKey } from '../utils/index'\nimport { apmAppId } from '../utils/apps'\n\nconst addressBookAppIds = [\n  apmAppId('address-book'),\n  apmAppId('address-book.open'),\n  apmAppId('address-book-experimental.open'),\n  apmAppId('tps-address-book.open'),\n  apmAppId('address-book-staging.open'),\n  apmAppId('address-book.hatch')\n]\n/**\n * An identity provider for Address Book Entries\n *\n * @extends AddressIdentityProvider\n */\nexport default class AddressBookIdentityProvider extends AddressIdentityProvider {\n  /**\n   * Create a new identity Provider that queries installed Address Book apps\n   * @param {Observable} apps apps Observable from the wrapper\n   * @param {Cache} cache the cache instance utilized by the wrapper\n   */\n  constructor (apps, cache) {\n    super()\n    this.apps = apps\n    this.cache = cache\n  }\n\n  /**\n   * Resolve the identity metadata for an address\n   * Should resolve to null if an identity does not exist\n   * Will return the first successful resolution                                                                                                                                                                                                                                tity could not be found\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with identity metadata or null if not found\n   */\n  async resolve (address) {\n    address = address.toLowerCase()\n    return this.apps.pipe(\n      concatAll(),\n      filter(app => addressBookAppIds.includes(app.appId)),\n      map(async app => {\n        const cacheKey = getCacheKey(app.proxyAddress, 'state')\n        const { entries = [] } = await this.cache.get(cacheKey)\n        const { data: metadata } = entries\n          .find(entry => entry.addr.toLowerCase() === address) || {}\n        if (!metadata) return null\n        metadata.source = 'addressBook'\n        return metadata\n      }),\n      flatMap(pendingEntryData => from(pendingEntryData)),\n      defaultIfEmpty(null),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Search for matches in the installed address books.\n   *\n   * If the search term starts with '0x', addresses will be matched for instead.\n   *\n   * @param  {string} searchTerm Search term\n   * @return {Promise} Resolved with array of matches, each containing the address and name\n   */\n  async search (searchTerm = '') {\n    const isAddressSearch = searchTerm.substring(0, 2).toLowerCase() === '0x'\n    const identities = await this.getAll()\n    const results = Object.entries(identities)\n      .filter(\n        ([address, { name }]) =>\n          (isAddressSearch &&\n            searchTerm.length > 3 &&\n            address.toLowerCase().indexOf(searchTerm.toLowerCase()) === 0) ||\n          name.toLowerCase().indexOf(searchTerm.toLowerCase()) > -1\n      )\n      .map(([address, { name }]) => ({ name, address }))\n    return results\n  }\n\n  /**\n   * get all identities from all installed address book instances\n   *\n   * @return {Promise} Resolved with an object of all identities when completed\n   */\n  async getAll () {\n    return this.apps.pipe(\n      first(),\n      concatAll(),\n      filter(app => addressBookAppIds.includes(app.appId)),\n      reduce(\n        async (allEntries, app) => {\n          const cacheKey = getCacheKey(app.proxyAddress, 'state')\n          const { entries = [] } = await this.cache.get(cacheKey)\n          const allEntriesResolved = await allEntries\n          const entriesObject = entries.reduce((obj, entry) => {\n            return { ...obj, [entry.addr.toLowerCase()]: entry.data }\n          }, {})\n          // ensure the entries retrieved from the first-installed address book aren't overwritten\n          return { ...entriesObject, ...allEntriesResolved }\n        },\n        Promise.resolve({})\n      )\n    ).toPromise()\n  }\n\n  /**\n   * Modify the identity metadata of an address\n   *\n   * @param  {string} address  Address to resolve\n   * @param  {Object} metadata Metadata to modify\n   * @return {Promise} Resolved success action or rejected error\n   */\n  async modify (address, metadata) {\n    throw new Error('Use the Address Book to change this label, or create your own local label')\n  }\n}\n"],"file":"AddressBookIdentityProvider.js"}