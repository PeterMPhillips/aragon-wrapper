{"version":3,"sources":["../../src/identity/LocalIdentityProvider.js"],"names":["LocalIdentityProvider","AddressIdentityProvider","constructor","identityCache","Cache","init","resolve","address","toLowerCase","cache","get","modify","name","createdAt","Date","now","Error","metadata","source","set","Promise","search","searchTerm","isAddressSearch","substring","identities","getAll","results","Object","entries","filter","length","indexOf","map","remove"],"mappings":";;;;;;;;;AAAA;;AACA;;AAGA;;;;;AAKe,MAAMA,qBAAN,SAAoCC,gCAApC,CAA4D;AACzE;;;AAGAC,EAAAA,WAAW,GAAI;AACb;AACA,SAAKC,aAAL,GAAqB,IAAIC,cAAJ,CAAU,eAAV,CAArB;AACD;;AAED,QAAMC,IAAN,GAAc;AACZ,UAAM,KAAKF,aAAL,CAAmBE,IAAnB,EAAN;AACD;AAED;;;;;;;;AAMAC,EAAAA,OAAO,CAAEC,OAAF,EAAW;AAChBA,IAAAA,OAAO,GAAGA,OAAO,CAACC,WAAR,EAAV;AACA,UAAMC,KAAK,GAAG,KAAKN,aAAL,CAAmBO,GAAnB,CAAuBH,OAAvB,CAAd;AACA,WAAOE,KAAP;AACD;AAED;;;;;;;;;AAOA,QAAME,MAAN,CAAcJ,OAAd,EAAuB;AAAEK,IAAAA,IAAI,GAAG,EAAT;AAAaC,IAAAA,SAAS,GAAGC,IAAI,CAACC,GAAL;AAAzB,MAAwC,EAA/D,EAAmE;AACjE,QAAI,CAACH,IAAL,EAAW;AACT,YAAM,IAAII,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACDT,IAAAA,OAAO,GAAGA,OAAO,CAACC,WAAR,EAAV;AAEA,UAAMS,QAAQ,GAAG;AAAEL,MAAAA,IAAF;AAAQC,MAAAA,SAAR;AAAmBK,MAAAA,MAAM,EAAE;AAA3B,KAAjB,CANiE,CAOjE;;AACA,UAAM,KAAKf,aAAL,CAAmBgB,GAAnB,CAAuBZ,OAAvB,EAAgCU,QAAhC,CAAN;AAEA,WAAOG,OAAO,CAACd,OAAR,CAAgB;AAAEC,MAAAA,OAAF;AAAWU,MAAAA;AAAX,KAAhB,CAAP;AACD;AAED;;;;;;;;;;AAQA,QAAMI,MAAN,CAAcC,UAAU,GAAG,EAA3B,EAA+B;AAC7B,UAAMC,eAAe,GAAGD,UAAU,CAACE,SAAX,CAAqB,CAArB,EAAwB,CAAxB,EAA2BhB,WAA3B,OAA6C,IAArE;AACA,UAAMiB,UAAU,GAAG,MAAM,KAAKtB,aAAL,CAAmBuB,MAAnB,EAAzB;AACA,UAAMC,OAAO,GAAGC,MAAM,CAACC,OAAP,CAAeJ,UAAf,EACbK,MADa,CAEZ,CAAC,CAACvB,OAAD,EAAU;AAAEK,MAAAA;AAAF,KAAV,CAAD,KACGW,eAAe,IACdD,UAAU,CAACS,MAAX,GAAoB,CADrB,IAECxB,OAAO,CAACC,WAAR,GAAsBwB,OAAtB,CAA8BV,UAAU,CAACd,WAAX,EAA9B,MAA4D,CAF9D,IAGAI,IAAI,CAACJ,WAAL,GAAmBwB,OAAnB,CAA2BV,UAAU,CAACd,WAAX,EAA3B,IAAuD,CAAC,CAN9C,EAQbyB,GARa,CAQT,CAAC,CAAC1B,OAAD,EAAU;AAAEK,MAAAA;AAAF,KAAV,CAAD,MAA0B;AAAEA,MAAAA,IAAF;AAAQL,MAAAA;AAAR,KAA1B,CARS,CAAhB;AASA,WAAOoB,OAAP;AACD;AAED;;;;;;;AAKA,QAAMD,MAAN,GAAgB;AACd,WAAO,KAAKvB,aAAL,CAAmBuB,MAAnB,EAAP;AACD;AAED;;;;;;;AAKA,QAAMQ,MAAN,CAAc3B,OAAd,EAAuB;AACrB,UAAM,KAAKJ,aAAL,CAAmB+B,MAAnB,CAA0B3B,OAAO,CAACC,WAAR,EAA1B,CAAN;AACD;;AApFwE","sourcesContent":["import Cache from '../cache'\nimport AddressIdentityProvider from './AddressIdentityProvider'\n\n\n/**\n * An local identity provider for addresses\n *\n * @class LocalIdentityProvider\n */\nexport default class LocalIdentityProvider extends AddressIdentityProvider {\n  /**\n   * Create a new identity provider attached to a locally-stored cache.\n   */\n  constructor () {\n    super()\n    this.identityCache = new Cache('localIdentity')\n  }\n\n  async init () {\n    await this.identityCache.init()\n  }\n\n  /**\n   * Resolve the locally-stored label for an address\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolved metadata, null when not found, rejected on error\n   */\n  resolve (address) {\n    address = address.toLowerCase()\n    const cache = this.identityCache.get(address)\n    return cache\n  }\n\n  /**\n   * Modify the locally-stored label of an address\n   *\n   * @param  {string} address  Address to resolve\n   * @param  {Object} metadata Metadata to modify\n   * @return {Promise} Resolved with saved address and metadata or rejected on error\n   */\n  async modify (address, { name = '', createdAt = Date.now() } = {}) {\n    if (!name) {\n      throw new Error('name is required when modifying a local identity')\n    }\n    address = address.toLowerCase()\n\n    const metadata = { name, createdAt, source: 'local' }\n    // First save it in the cache\n    await this.identityCache.set(address, metadata)\n\n    return Promise.resolve({ address, metadata })\n  }\n\n  /**\n   * Search for matches in the locally-stored labels.\n   *\n   * If the search term starts with '0x', addresses will be matched for instead.\n   *\n   * @param  {string} searchTerm Search term\n   * @return {Promise} Resolved with array of matches, each containing the address and name\n   */\n  async search (searchTerm = '') {\n    const isAddressSearch = searchTerm.substring(0, 2).toLowerCase() === '0x'\n    const identities = await this.identityCache.getAll()\n    const results = Object.entries(identities)\n      .filter(\n        ([address, { name }]) =>\n          (isAddressSearch &&\n            searchTerm.length > 3 &&\n            address.toLowerCase().indexOf(searchTerm.toLowerCase()) === 0) ||\n          name.toLowerCase().indexOf(searchTerm.toLowerCase()) > -1\n      )\n      .map(([address, { name }]) => ({ name, address }))\n    return results\n  }\n\n  /**\n   * Get all local identities\n   *\n   * @return {Promise} Resolved with an object of all identities when completed\n   */\n  async getAll () {\n    return this.identityCache.getAll()\n  }\n\n  /**\n   * Remove a single identity from the local cache\n   *\n   * @return {Promise} Resolved when completed\n   */\n  async remove (address) {\n    await this.identityCache.remove(address.toLowerCase())\n  }\n}\n"],"file":"LocalIdentityProvider.js"}